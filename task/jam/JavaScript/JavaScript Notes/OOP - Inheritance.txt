Inheritance
Some matrices are known to be symmetric. If you mirror a symmetric matrix around its top-left-to-bottom-right diagonal, 
it stays the same. In other words, the value stored at x,y is always the same as that at y,x.

Inherits the same process and apply to the procedure.

The new class inherits properties and behavior from the old class.

class SymmetricMatrix extends Matrix {
  constructor(size, element = (x, y) => undefined) {
    super(size, size, (x, y) => {
      if (x < y) return element(y, x);
      else return element(x, y);
    });
  }

  set(x, y, value) {
    super.set(x, y, value);
    if (x != y) {
      super.set(y, x, value);
    }
  }
}

let matrix = new SymmetricMatrix(5, (x, y) => `${x},${y}`);
console.log(matrix.get(2, 3));
// → 3,2


The use of the word extends indicates that this class shouldn’t be directly based on the default Object prototype but on some other class. This is called the superclass. The derived class is the subclass.

Inheritance allows us to build slightly different data types from existing data types with relatively little work.



uses the keyword 'extends <parent class>' to inherit the functions from the parent class.


On this example the class 'Model' inherits the behavior of parent Car
class Car {
  constructor(brand) {
    this.carname = brand;
  }
  present() {
    return 'I have a ' + this.carname;
  }
}

The super() method refers to the parent class.

By calling the super() method in the constructor method, 
we call the parent's constructor method and gets access to the parent's properties and methods.

class Model extends Car {
  constructor(brand, mod) {
    super(brand);
    this.model = mod;
  }
  show() {
    return this.present() + ', it is a ' + this.model;
  }
}
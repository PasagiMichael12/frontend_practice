Inheritance
Some matrices are known to be symmetric. If you mirror a symmetric matrix around its top-left-to-bottom-right diagonal, 
it stays the same. In other words, the value stored at x,y is always the same as that at y,x.

Inherits the same process and apply to the procedure.

The new class inherits properties and behavior from the old class.

class SymmetricMatrix extends Matrix {
  constructor(size, element = (x, y) => undefined) {
    super(size, size, (x, y) => {
      if (x < y) return element(y, x);
      else return element(x, y);
    });
  }

  set(x, y, value) {
    super.set(x, y, value);
    if (x != y) {
      super.set(y, x, value);
    }
  }
}

let matrix = new SymmetricMatrix(5, (x, y) => `${x},${y}`);
console.log(matrix.get(2, 3));
// → 3,2


The use of the word extends indicates that this class shouldn’t be directly based on the default Object prototype but on some other class. This is called the superclass. The derived class is the subclass.

Inheritance allows us to build slightly different data types from existing data types with relatively little work.



uses the keyword 'extends <parent class>' to inherit the functions from the parent class.


On this example the class 'Model' inherits the behavior of parent Car
class Car {
  constructor(brand) {
    this.carname = brand;
  }
  present() {
    return 'I have a ' + this.carname;
  }
}

The super() method refers to the parent class.

By calling the super() method in the constructor method, 
we call the parent's constructor method and gets access to the parent's properties and methods.

class Model extends Car {
  constructor(brand, mod) {
    super(brand);
    this.model = mod;
  }
  show() {
    return this.present() + ', it is a ' + this.model;
  }
}

call() function. 
This function basically allows you to call a function defined somewhere else, but in the current context
function Teacher(first, last, age, gender, interests, subject) {
  Person.call(this, first, last, age, gender, interests);

  this.subject = subject;
}

Prototype Inheritance
All JavaScript objects inherit properties and methods from a prototype:

Date objects inherit from Date.prototype
Array objects inherit from Array.prototype
Person objects inherit from Person.prototype
The Object.prototype is on the top of the prototype inheritance chain:

Date objects, Array objects, and Person objects inherit from Object.prototype.

The JavaScript prototype property allows you to add new properties to object constructors:
function Person(first, last, age, eyecolor) {
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eyecolor;
}

Person.prototype.nationality = "English";

The JavaScript prototype property also allows you to add new methods to objects constructors:

Example
function Person(first, last, age, eyecolor) {
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eyecolor;
}

Person.prototype.name = function() {
  return this.firstName + " " + this.lastName;
};



using the EXTENDS keyword

parent: 'super class' 

class Particle{
  constructor(x, y){
    this.x = x;
    this.y = y;
  }
}

child: 'subclass'

class Square extends Particle{
  //inherits the behavior of the parent class
}

using the SUPER(<constructor paramete>) keyword

call & execute the contructor function from the parent class

parent: 
class Particle{
  constructor(){
    
  }
}

class Square extends Particle{
  //extends keyword inherits the behavior of the parent class

  constructor(x, y){
    super(x, y);
  }
}

JavaScript uses prototypal inheritance.
https://stackoverflow.com/questions/2800964/benefits-of-prototypal-inheritance-over-classical

The constructor pattern in JavaScript is the prototypal pattern inverted. Instead of creating an object you create a constructor. 
The new keyword binds the this pointer inside the constructor to a clone of the prototype of the constructor.

two things to make prototypal inheritance work:

A way to create a new object (e.g. object literals).
A way to extend an existing object (e.g. Object.create).
Prototypal Inheritance is Dynamic
One of the most important advantages of prototypal inheritance is that you can add new properties to prototypes after they are created. This allows you to add new methods 
to a prototype which will be automatically made available to all the objects which delegate to that prototype.